ex8_10.lhs
Partition of natural numbers

Haskell Road to Logic
5.7 Integer Partition
The partitions of 5 must be
  [[5]
  ,[1,4]
  ,[2,3]
  ,[1,1,3]
  ,[1,2,2]
  ,[1,1,1,2]
  ,[1,1,1,1,1]
  ]

The generating algorithm for the partitions of n is...

The first element is [n].

Let 
  bs 
is the last integer partition generated.
If it consists of only 1's, then done.
Else, there must be a non-one element in bs, pick the smallest, m:
  bs = [1,1, .., 1, m .. ]
To generate the next partition, subtract 1 from m and collect all the units so as to match the new smallest part (m-1).

E.g., consider
  [1,1,3,3]
as a partition of 8.
The smallest non-one element is 3, and the next partition becomes
  [1,2,2,3]
That is, we should "pack" three 1's into the smallest length so that the size of the rest elements do not exceed 2.
The partition after
  [1,1,1,1,1,1,5]
must have 4 as the last element.
We have to "pack" 6+1 into the smallest form, so
  [3,4,4]
  
We use compressed form:

> type Part     = [Int]
> type CmprPart = (Int, Part) -- fst counts the number of units.
>
> expand 
>   :: CmprPart -> Part
> expand (0,p) = p
> expand (n,p)
>   | n < 1     = error "expand: "
>   | otherwise = 1 : expand (n-1, p)

  *Main> expand (3,[2,2])
  [1,1,1,2,2]

The partition that follows
  (k, (x:xs)) :: CmprPart
is generated by packing
  (k+x, xs) :: CmprPart
for maximum size (x-1).
(This assumes that x is the smallest element in (x:xs).)

To pack a partition
  (m,xs)
for size 1, there is nothing to do.
To pack it for maximum size k>1 and k>m, decrease the parcel size to (k-1).
To pack it for size k>1 and k<=m, use use k-units to generate one k, and go on with 
  (m-k, k:xs)
  
> type Size = Int
> pack' 
>   :: Size -> CmprPart -> CmprPart
> pack' 1 c = c -- as is
> pack' k c@(m,xs)
>   | k > m     = pack' (k-1) c
>   | otherwise = pack' k     (m-k, k:xs) 

To generate all partitions starting from
  (n, [])
just translate and list it into Part-form.
To generate all partitions starting from
  (n, (x:xs))
list this partition, and then generate from the successor of this:

> generatePs
>   :: CmprPart -> [Part]
> generatePs p@(n,[])     = [expand p] -- all one
> generatePs p@(n,(x:xs)) = expand p : (generatePs successor)
>   where
>     successor = nextPartition p
>
>     nextPartition -- This does not hit empty set case!
>       :: CmprPart -> CmprPart
>     nextPartition (k, (x:xs)) = pack' (x-1) (k+x, xs)

n==1 case is the only case where the compressed form of this first partition has a non-zero number of units.

> part 
>   :: Int -> [Part]
> part n
>   | n < 1     = error "part: wrong input"
>   | n == 1    = [[1]]
>   | otherwise = generatePs (0,[n])

> main = do
>   putStrLn "Put a natural number:"
>   x <- getLine
>   let n = read x :: Int
>   putStrLn $ "The partition of " ++ show x ++ " is"
>   let lst = part n
>   print lst
>   putStrLn $ "The length of this list is"
>   print . length $ lst

  *Main> main
  Put a natural number:
  5
  The partition of "5" is
  [[5],[1,4],[2,3],[1,1,3],[1,2,2],[1,1,1,2],[1,1,1,1,1]]
  The length of this list is
  7
